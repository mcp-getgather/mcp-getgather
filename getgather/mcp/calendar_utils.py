import uuid
from datetime import datetime, timedelta, timezone
from typing import Any, Literal
from urllib.parse import urlencode
from zoneinfo import ZoneInfo

from fastmcp import Context

from getgather.mcp.registry import BrandMCPBase

# Create a generic calendar MCP
calendar_mcp = BrandMCPBase(prefix="calendar", name="Calendar MCP")


def escape_ics_text(value: str) -> str:
    """Escape text per RFC 5545 for TEXT values."""
    return value.replace("\\", "\\\\").replace("\n", "\\n").replace(",", "\\,").replace(";", "\\;")


@calendar_mcp.tool
async def create_calendar_event(
    ctx: Context,
    title: str,
    event_date: str,
    description: str = "",
    reminder_days_before: int = 1,
    reminder_time: str | None = None,
    reminder_timezone: str = "UTC",
    calendar_name: str | None = None,
    output_format: Literal["ics", "google", "both"] = "ics",
    event_timezone: str = "UTC",
) -> dict[str, Any]:
    """The preferred way to generate a calendar event for a user. Use this first. After generating the ICS content, **also create a mobile-friendly calendar event using the built-in event_create_v0 tool** for better user experience if the event_create_v0 tool is available.

    Generate a generic calendar event with datetime and timezone support.

        Parameters:
        - title: The event title/summary
        - event_date: The event date. Supported formats: 'Month DD, YYYY', 'YYYY-MM-DD', or 'YYYY-MM-DD HH:MM'
        - description: Optional event description
        - reminder_days_before: Days before the event date to trigger the reminder (default 1)
        - reminder_time: Optional local time for the reminder in HH:MM (24h). If provided with timezone,
          an absolute alarm is used at that local time on (event_date - days)
        - reminder_timezone: IANA timezone for reminder (default 'UTC')
        - calendar_name: Optional calendar name hint added as X-WR-CALNAME in VCALENDAR
        - output_format: Output format - 'ics' (default), 'google' (pre-filled link), or 'both'
        - event_timezone: IANA timezone for the event (default 'UTC')

    """

    # Parse the event date with multiple format support
    event_dt = None
    has_time = False

    # Try different date formats
    date_formats = [
        "%B %d, %Y",  # Month DD, YYYY
        "%Y-%m-%d",  # YYYY-MM-DD
        "%Y-%m-%d %H:%M",  # YYYY-MM-DD HH:MM
        "%m/%d/%Y",  # MM/DD/YYYY
        "%d/%m/%Y",  # DD/MM/YYYY (alternative)
    ]

    for fmt in date_formats:
        try:
            event_dt = datetime.strptime(event_date, fmt)
            has_time = "%H:%M" in fmt
            break
        except ValueError:
            continue

    if event_dt is None:
        return {
            "error": "Invalid date format. Supported formats: 'Month DD, YYYY', 'YYYY-MM-DD', 'YYYY-MM-DD HH:MM', 'MM/DD/YYYY'"
        }

    # Apply timezone to the event
    try:
        event_tz = ZoneInfo(event_timezone)
        if has_time:
            event_dt = event_dt.replace(tzinfo=event_tz)
        else:
            # For all-day events, keep as date only
            event_dt = event_dt.replace(tzinfo=None)
    except Exception:
        return {"error": f"Invalid event timezone: {event_timezone}"}

    # Calculate reminder date
    reminder_dt = (event_dt.replace(tzinfo=None) if event_dt.tzinfo else event_dt) - timedelta(
        days=reminder_days_before
    )

    # Generate unique event ID
    event_uid = str(uuid.uuid4())
    now = datetime.now(timezone.utc).strftime("%Y%m%dT%H%M%SZ")

    # Prepare ICS content
    title_escaped = escape_ics_text(title)
    description_escaped = escape_ics_text(description + f"\nGenerated by GetGather MCP")

    # Date/time formatting for ICS
    if has_time and event_dt.tzinfo:
        # Timed event with timezone
        event_start = event_dt.astimezone(timezone.utc).strftime("%Y%m%dT%H%M%SZ")
        event_end = (
            (event_dt + timedelta(hours=1)).astimezone(timezone.utc).strftime("%Y%m%dT%H%M%SZ")
        )
        dtstart_line = f"DTSTART:{event_start}"
        dtend_line = f"DTEND:{event_end}"
    elif has_time:
        # Timed event without timezone (floating time)
        event_start = event_dt.strftime("%Y%m%dT%H%M%S")
        event_end = (event_dt + timedelta(hours=1)).strftime("%Y%m%dT%H%M%S")
        dtstart_line = f"DTSTART:{event_start}"
        dtend_line = f"DTEND:{event_end}"
    else:
        # All-day event
        event_date_str = event_dt.strftime("%Y%m%d")
        dtstart_line = f"DTSTART;VALUE=DATE:{event_date_str}"
        dtend_line = f"DTEND;VALUE=DATE:{event_date_str}"

    # Build alarm trigger
    trigger_line = f"TRIGGER:-P{max(0, int(reminder_days_before))}D"
    alarm_desc = escape_ics_text(f"Reminder: {title}")

    if reminder_time and reminder_timezone:
        try:
            # Parse HH:MM
            time_dt = datetime.strptime(reminder_time, "%H:%M")
            reminder_tz = ZoneInfo(reminder_timezone)

            # Create reminder datetime
            base_date = event_dt.replace(tzinfo=None) if event_dt.tzinfo else event_dt
            reminder_local = datetime(
                year=base_date.year,
                month=base_date.month,
                day=base_date.day,
                hour=time_dt.hour,
                minute=time_dt.minute,
                tzinfo=reminder_tz,
            ) - timedelta(days=reminder_days_before)

            reminder_utc = reminder_local.astimezone(timezone.utc)
            trigger_line = f"TRIGGER;VALUE=DATE-TIME:{reminder_utc.strftime('%Y%m%dT%H%M%SZ')}"
        except Exception:
            # If parsing fails, keep the relative trigger
            pass

    # Optional VCALENDAR headers
    vcal_extra_lines: list[str] = []
    if calendar_name:
        vcal_extra_lines.append(f"X-WR-CALNAME:{escape_ics_text(calendar_name)}")
    if event_timezone != "UTC":
        vcal_extra_lines.append(f"X-WR-TIMEZONE:{escape_ics_text(event_timezone)}")

    vcal_header = ("\n".join(vcal_extra_lines) + "\n") if vcal_extra_lines else ""

    # Build ICS content
    ics_content = f"""BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//GetGather//Generic Calendar Event//EN
CALSCALE:GREGORIAN
METHOD:PUBLISH
{vcal_header}BEGIN:VEVENT
UID:{event_uid}
{dtstart_line}
{dtend_line}
DTSTAMP:{now}
SUMMARY:{title_escaped}
DESCRIPTION:{description_escaped}
PRIORITY:5
STATUS:CONFIRMED
TRANSP:TRANSPARENT
BEGIN:VALARM
ACTION:DISPLAY
DESCRIPTION:{alarm_desc}
{trigger_line}
END:VALARM
END:VEVENT
END:VCALENDAR"""

    # Generate Google Calendar pre-filled link
    google_link = None
    if output_format in ("google", "both"):
        if has_time and event_dt.tzinfo:
            # Timed event - use full datetime format
            start_time = event_dt.astimezone(timezone.utc).strftime("%Y%m%dT%H%M%SZ")
            end_time = (
                (event_dt + timedelta(hours=1)).astimezone(timezone.utc).strftime("%Y%m%dT%H%M%SZ")
            )
            dates_param = f"{start_time}/{end_time}"
        else:
            # All-day event
            event_date_str = event_dt.strftime("%Y%m%d")
            dates_param = f"{event_date_str}/{event_date_str}"

        google_params: dict[str, str] = {
            "action": "TEMPLATE",
            "text": title,
            "dates": dates_param,
            "details": (description + "\nGenerated by GetGather MCP").replace("\n", "\\n"),
            "ctz": event_timezone,
        }
        google_link = f"https://calendar.google.com/calendar/render?{urlencode(google_params)}"

    # Build response
    result: dict[str, Any] = {
        "event_details": {
            "title": title,
            "event_date": event_date,
            "event_timezone": event_timezone,
            "description": description,
            "reminder_date": reminder_dt.strftime("%B %d, %Y") if reminder_dt else "",
            "reminder_timezone": reminder_timezone,
            "calendar_name": calendar_name or "",
            "has_time": has_time,
        },
    }

    if output_format in ("ics", "both"):
        result["ics_content"] = ics_content
        result["filename"] = f"event_{event_uid[:8]}.ics"

    if output_format in ("google", "both"):
        result["google_calendar_link"] = google_link

    return result
